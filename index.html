<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Blast Basit Oyun</title>
<style>
  body {
    margin: 0; padding: 0;
    background: #222;
    color: white;
    font-family: monospace;
    text-align: center;
    user-select: none;
  }
  #score {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 20px;
    font-weight: bold;
  }
  #game {
    margin: 60px auto;
    display: grid;
    grid-template-columns: repeat(8, 50px);
    grid-template-rows: repeat(8, 50px);
    gap: 4px;
    width: max-content;
    touch-action: none;
  }
  .block {
    width: 50px;
    height: 50px;
    border-radius: 6px;
    cursor: pointer;
    transition: transform 0.2s ease;
  }
  .selected {
    outline: 3px solid white;
    transform: scale(1.1);
  }
</style>
</head>
<body>

<div id="score">Skor: 0</div>
<div id="game"></div>

<script>
const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22'];
const rows = 8;
const cols = 8;
let board = [];
let score = 0;
let firstSelected = null;
const gameEl = document.getElementById('game');
const scoreEl = document.getElementById('score');

function randomColor() {
  return Math.floor(Math.random() * colors.length);
}

function initBoard() {
  board = [];
  for(let r=0; r<rows; r++) {
    const row = [];
    for(let c=0; c<cols; c++) {
      row.push(randomColor());
    }
    board.push(row);
  }
  // Patlamaya hazır olanları kaldır (başlangıçta)
  while (findMatches().length > 0) {
    removeMatches();
    applyGravity();
    refillBoard();
  }
}

function drawBoard() {
  gameEl.innerHTML = '';
  for(let r=0; r<rows; r++) {
    for(let c=0; c<cols; c++) {
      const block = document.createElement('div');
      block.classList.add('block');
      block.style.backgroundColor = colors[board[r][c]];
      block.dataset.r = r;
      block.dataset.c = c;
      block.addEventListener('click', () => onBlockClick(r, c));
      gameEl.appendChild(block);
    }
  }
}

function onBlockClick(r, c) {
  if(firstSelected === null) {
    firstSelected = {r,c};
    highlightBlock(r,c,true);
  } else {
    if(isAdjacent(firstSelected, {r,c})) {
      swapBlocks(firstSelected, {r,c});
      if(findMatches().length > 0) {
        processMatches();
      } else {
        // Geçerli hamle değil, geri al
        swapBlocks(firstSelected, {r,c});
      }
    }
    highlightBlock(firstSelected.r, firstSelected.c, false);
    firstSelected = null;
  }
}

function highlightBlock(r,c,on) {
  const blocks = gameEl.children;
  for(let i=0; i<blocks.length; i++) {
    const b = blocks[i];
    if(+b.dataset.r === r && +b.dataset.c === c) {
      if(on) b.classList.add('selected');
      else b.classList.remove('selected');
      break;
    }
  }
}

function isAdjacent(a,b) {
  return (Math.abs(a.r - b.r) + Math.abs(a.c - b.c)) === 1;
}

function swapBlocks(a,b) {
  const temp = board[a.r][a.c];
  board[a.r][a.c] = board[b.r][b.c];
  board[b.r][b.c] = temp;
  drawBoard();
}

function findMatches() {
  const matches = [];

  // Yatay kontrol
  for(let r=0; r<rows; r++) {
    let count = 1;
    for(let c=1; c<cols; c++) {
      if(board[r][c] === board[r][c-1]) {
        count++;
      } else {
        if(count >= 3) {
          for(let k=c-count; k<c; k++) matches.push([r,k]);
        }
        count = 1;
      }
    }
    if(count >=3) {
      for(let k=cols-count; k<cols; k++) matches.push([r,k]);
    }
  }
  // Dikey kontrol
  for(let c=0; c<cols; c++) {
    let count = 1;
    for(let r=1; r<rows; r++) {
      if(board[r][c] === board[r-1][c]) {
        count++;
      } else {
        if(count >=3) {
          for(let k=r-count; k<r; k++) matches.push([k,c]);
        }
        count=1;
      }
    }
    if(count >=3) {
      for(let k=rows-count; k<rows; k++) matches.push([k,c]);
    }
  }
  return matches;
}

function removeMatches() {
  const matches = findMatches();
  if(matches.length === 0) return false;
  for(const [r,c] of matches) {
    board[r][c] = null;
  }
  score += matches.length * 10;
  scoreEl.textContent = 'Skor: ' + score;
  return true;
}

function applyGravity() {
  for(let c=0; c<cols; c++) {
    for(let r=rows-1; r>=0; r--) {
      if(board[r][c] === null) {
        for(let rr=r-1; rr>=0; rr--) {
          if(board[rr][c] !== null) {
            board[r][c] = board[rr][c];
            board[rr][c] = null;
            break;
          }
        }
      }
    }
  }
}

function refillBoard() {
  for(let r=0; r<rows; r++) {
    for(let c=0; c<cols; c++) {
      if(board[r][c] === null) {
        board[r][c] = randomColor();
      }
    }
  }
}

function processMatches() {
  if(removeMatches()) {
    applyGravity();
    refillBoard();
    drawBoard();
    // Biraz gecikmeli tekrar kontrol et (kaskad efekt)
    setTimeout(processMatches, 300);
  }
}

initBoard();
drawBoard();
</script>

</body>
</html>
